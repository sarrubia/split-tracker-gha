var _a;
import { uniqueId } from '../lang';
import { timer } from './timer';
import { thenable } from '../promise/thenable';
// Map we will use for storing timers data
var timers = {};
// Tasks constants
var CONSTANTS = {
    SDK_READY: 'Getting ready - Split SDK',
    SDK_GET_TREATMENT: 'SDK - Get Treatment',
    SDK_GET_TREATMENTS: 'SDK - Get Treatments',
    SDK_GET_TREATMENT_WITH_CONFIG: 'SDK - Get Treatment with config',
    SDK_GET_TREATMENTS_WITH_CONFIG: 'SDK - Get Treatments with config',
    SPLITS_READY: 'Getting ready - Splits',
    SEGMENTS_READY: 'Getting ready - Segments',
    METRICS_PUSH: 'Pushing - Metrics',
    IMPRESSIONS_PUSH: 'Pushing - Impressions',
    EVENTS_PUSH: 'Pushing - Events',
    MY_SEGMENTS_FETCH: 'Fetching - My Segments',
    SEGMENTS_FETCH: 'Fetching - Segments',
    SPLITS_FETCH: 'Fetching - Splits'
};
// Tasks callbacks, if any
var CALLBACKS = (_a = {},
    _a[CONSTANTS.SDK_READY] = {
        collector: 'client',
        method: 'ready'
    },
    _a[CONSTANTS.SDK_GET_TREATMENT] = {
        collector: 'client',
        method: 'getTreatment'
    },
    _a[CONSTANTS.SDK_GET_TREATMENTS] = {
        collector: 'client',
        method: 'getTreatments'
    },
    _a[CONSTANTS.SDK_GET_TREATMENT_WITH_CONFIG] = {
        collector: 'client',
        method: 'getTreatmentWithConfig'
    },
    _a[CONSTANTS.SDK_GET_TREATMENTS_WITH_CONFIG] = {
        collector: 'client',
        method: 'getTreatmentsWithConfig'
    },
    _a[CONSTANTS.MY_SEGMENTS_FETCH] = {
        collector: 'mySegments',
        method: 'latency'
    },
    _a[CONSTANTS.SEGMENTS_FETCH] = {
        collector: 'segmentChanges',
        method: 'latency'
    },
    _a[CONSTANTS.SPLITS_FETCH] = {
        collector: 'splitChanges',
        method: 'latency'
    },
    _a);
/**
 * Generates the timer keys using the task name and a modifier, if any.
 * @param {string} task - The task name
 * @param {number | string} modifier - (optional) The modifier, if any.
 * @return {string} The generated timer key
 */
function generateTimerKey(task, modifier) { return modifier ? task + modifier : task; }
/**
 * Given the collectors map, it returns the specific collector for a given task.
 *
 * @param {string} task - The task name
 * @param {Object} collectors - The collectors map
 */
function getCollectorForTask(task, collectors) {
    var callbackData = CALLBACKS[task];
    if (callbackData && collectors)
        return collectors[callbackData.collector];
    return false;
}
/**
 * Given a collector and a task, returns the callback function that should be called when we stop the timer.
 *
 * @param {string} task - The task name
 * @param {Object} collector - The collector object for the task
 */
function getCallbackForTask(task, collector) {
    var callbackData = CALLBACKS[task];
    if (callbackData && collector)
        return collector[callbackData.method];
    return false;
}
// Our "time tracker" API
export var TrackerAPI = {
    /**
     * "Private" method, used to attach count/countException and stop callbacks to a promise.
     *
     * @param {ILogger} log - Logger.
     * @param {Promise} promise - The promise we want to attach the callbacks.
     * @param {string} task - The name of the task.
     * @param {number | string} modifier - (optional) The modifier for the task, if any.
     */
    __attachToPromise: function (log, promise, task, collector, modifier) {
        var _this = this;
        return promise.then(function (resp) {
            _this.stop(log, task, modifier);
            if (collector && collector.count)
                collector.count(resp.status);
            return resp;
        })
            .catch(function (err) {
            _this.stop(log, task, modifier);
            if (collector && collector.countException)
                collector.countException();
            throw err;
        });
    },
    /**
     * Starts tracking the time for a given task. All tasks tracked are considered "unique" because
     * there may be multiple SDK instances tracking a "generic" task, making any task non-generic.
     *
     * @param {ILogger} log - Logger.
     * @param {string} task - The task we are starting.
     * @param {Object} collectors - The collectors map.
     * @param {Promise} promise - (optional) The promise we are tracking.
     * @return {Function | Promise} The stop function for this specific task or the promise received with the callbacks registered.
     */
    start: function (log, task, collectors, promise, now) {
        var taskUniqueId = uniqueId();
        var taskCollector = getCollectorForTask(task, collectors);
        var result;
        // If we are registering a promise with this task, we should count the status and the exceptions as well
        // as stopping the task when the promise resolves. Then return the promise
        if (thenable(promise)) {
            result = this.__attachToPromise(log, promise, task, taskCollector, taskUniqueId);
        }
        else {
            // If not, we return the stop function, as it will be stopped manually.
            result = this.stop.bind(this, log, task, taskUniqueId);
            if (CALLBACKS[task] && !taskCollector) {
                // and provide a way for a defered setup of the collector, if needed.
                // @ts-expect-error
                result.setCollectorForTask = this.setCollectorForTask.bind(this, task, taskUniqueId);
            }
        }
        // We start the timer, with an uniqueId attached to it's name, and save tracking info for this task.
        var trackingKey = generateTimerKey(task, taskUniqueId);
        var cb = getCallbackForTask(task, taskCollector);
        timers[trackingKey] = {
            cb: cb,
            timer: timer(now)
        };
        return result;
    },
    /**
     * Setup the collector for a task that reports metrics.
     *
     * @param {string} task - The task name
     * @param {number | string} taskUniqueId - The unique identifier for this task
     * @param {Object} collectors - The collectors map.
     */
    setCollectorForTask: function (task, taskUniqueId, collectors) {
        var taskCollector = getCollectorForTask(task, collectors);
        if (taskCollector) {
            var trackingKey = generateTimerKey(task, taskUniqueId);
            timers[trackingKey].cb = getCallbackForTask(task, taskCollector);
        }
    },
    /**
     * Stops the tracking of a given task.
     *
     * @param {ILogger} log - Logger.
     * @param {string} task - The task we are starting.
     * @param {number | string} modifier - (optional) The modifier for that specific task.
     */
    stop: function (log, task, modifier) {
        var timerName = generateTimerKey(task, modifier);
        var timerData = timers[timerName];
        if (timerData) {
            // Stop the timer and round result for readability.
            var et = timerData.timer();
            log.debug("[TIME TRACKER]: [" + task + "] took " + et + "ms to finish.");
            // Check if we have a tracker callback.
            if (timerData.cb) {
                // If we have a callback, we call it with the elapsed time of the task and then delete the reference.
                timerData.cb(et);
            }
            // Remove the task tracking reference.
            delete timers[timerName];
            return et;
        }
    },
    /**
     * The constants shortcut for the task names.
     */
    TaskNames: CONSTANTS
};
