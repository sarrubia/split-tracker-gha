"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.impressionsSyncTaskFactory = exports.fromImpressionsCollector = void 0;
var lang_1 = require("../../utils/lang");
var submitterSyncTask_1 = require("./submitterSyncTask");
var constants_1 = require("../../logger/constants");
var DATA_NAME = 'impressions';
/**
 * Converts `impressions` data from cache into request payload.
 */
function fromImpressionsCollector(sendLabels, data) {
    var groupedByFeature = (0, lang_1.groupBy)(data, 'feature');
    var dto = [];
    // using forOwn instead of for...in since the last also iterates over prototype enumerables
    (0, lang_1.forOwn)(groupedByFeature, function (value, name) {
        dto.push({
            f: name,
            i: value.map(function (entry) {
                var keyImpression = {
                    k: entry.keyName,
                    t: entry.treatment,
                    m: entry.time,
                    c: entry.changeNumber,
                    r: sendLabels ? entry.label : undefined,
                    b: entry.bucketingKey ? entry.bucketingKey : undefined,
                    pt: entry.pt ? entry.pt : undefined // Previous time
                };
                return keyImpression;
            })
        });
    });
    return dto;
}
exports.fromImpressionsCollector = fromImpressionsCollector;
/**
 * Sync task that periodically posts impressions data
 */
function impressionsSyncTaskFactory(log, postTestImpressionsBulk, impressionsCache, impressionsRefreshRate, sendLabels, latencyTracker) {
    if (sendLabels === void 0) { sendLabels = false; }
    // retry impressions only once.
    var syncTask = (0, submitterSyncTask_1.submitterSyncTaskFactory)(log, postTestImpressionsBulk, impressionsCache, impressionsRefreshRate, DATA_NAME, latencyTracker, fromImpressionsCollector.bind(undefined, sendLabels), 1);
    // register impressions submitter to be executed when impressions cache is full
    impressionsCache.setOnFullQueueCb(function () {
        if (syncTask.isRunning()) {
            log.info(constants_1.SUBMITTERS_PUSH_FULL_QUEUE, [DATA_NAME]);
            syncTask.execute();
        }
        // If submitter is stopped (e.g., user consent declined or unknown, or app state offline), we don't send the data.
        // Data will be sent when submitter is resumed.
    });
    return syncTask;
}
exports.impressionsSyncTaskFactory = impressionsSyncTaskFactory;
